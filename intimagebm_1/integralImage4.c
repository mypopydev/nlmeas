// This program is free software: you can use, modify and/or redistribute it
// under the terms of the simplified BSD License. You should have received a
// copy of this license along this program. If not, see
// <http://www.opensource.org/licenses/bsd-license.html>.
//
// Copyright 2013, Gabriele Facciolo <facciolo@cmla.ens-cachan.fr>
// Copyright 2013, Nicolas Limare <nicolas.limare@cmla.ens-cachan.fr>
// All rights reserved.

/**
 * @file   integralImage4.c
 * @author Gabriele Facciolo <gfacciol@cmla.ens-cachan.fr>
 * @author Nicolas Limare <nicolas.limare@cmla.ens-cachan.fr>
 * @date   Aug, 2013
 * @brief  Integral image generation and evaluation routines.
 *
 * Implementation of the Viola-Jones Integral Image :
 * [1]  Viola, Jones: Robust Real-time Object Detection, IJCV 2001
 *
 * Routines for computing the integral image for a single channel image,
 * and for multi-channel images.
 * Include tweak for removing the mean of the channel.
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#include "utils.inc.c"

/**
 *  IIFLOAT: is the type of storage for the integral image
 * it can be set to double without much effect or
 * to float for very small or integer-valued images.*/
#ifndef IIFLOAT
#define IIFLOAT long double
#endif

typedef IIFLOAT iifloat_t;


struct iimage_t {
   int sz[3];			//[col,row,ch]
   iifloat_t *AVERAGE;
   iifloat_t *data;
};



/**
 * If set, preprocess the data before computing the integral image
 * by removing the average value, this increases the precision in 1 bit.
 * Usually not necessary with double and long double (64 and 80 bits resp)*/
#define _USEAVERAGE 0

// mute explicitly unused parameters
#define UNUSED(x) (void)(x)

/**
 * Variation on the Viola-Jones Integral Image, with a single scalar
 * temporary variable.
 *
 * Computes the integral image of a single channel image u and stores
 * it in ii: 
 *    ii(x,y) = \sum_{p \le x , q\le y} u(p,q)
 * The output ii must be a pre-allocated array with the same size as
 * u: (nc x nr). Input array pointer u and output array pointer ii can
 * be identical for an in-place operation. 
 **/
void computeIntegralImage(iifloat_t * u, int nc, int nr, iifloat_t * ii)
{
   // compute the integral image by the recurrence:
   //    s(x,y)  = s(x-1,y) + u(x,y)
   //   ii(x,y) = ii(x,y-1) + s(x,y)
   // with s(0,y) = u(0,y) ; and ii(0,0) = u(0,0)

   // first cell
   ii[0] = u[0];
   // first row
   for (int x = 1; x < nc; x++)
      ii[x] = ii[x - 1] + u[x];
   // next rows
   for (int y = 1; y < nr; y++) {
      // first cell of the row
      iifloat_t s = u[nc * y];	// current row cumulative sum
      ii[nc * y] = ii[nc * (y - 1)] + s;
      // next cells
      for (int x = 1; x < nc; x++) {
	 s = s + u[x + nc * y];
	 ii[x + nc * y] = ii[x + nc * (y - 1)] + s;
      }
   }
}


/**
 * Computes the sum on a block of size (w*h) from (x0,y0) inclusive, by
 * evaluating the integral image ii as generated by computeIntegralImage.
 **/
iifloat_t evaluateIntegralImageBlock(iifloat_t * ii, int nc, int nr,
				     int x0, int y0, int w, int h)
{
   /*
    *   xm,ym  O<-----w------->O  xp,ym
    *      y0,x0 X x x x x x x X  y0,x1
    *          | x x x x x x x x
    *          h x x x x x x x x
    *          | x x x x x x x x
    *   yp,xm  O X x x x x x x O  yp,xp = y1,x1
    *          y1,x0
    * */
   UNUSED(nr);
   int xm = x0 - 1;
   int xp = xm + w;
   int ym = y0 - 1;
   int yp = ym + h;

   iifloat_t retval = 0;

   retval += ii[xp + yp * nc];
   if (xm >= 0)
      retval -= ii[xm + yp * nc];
   if (ym >= 0)
      retval -= ii[xp + ym * nc];
   if (xm >= 0 && ym >= 0)
      retval += ii[xm + ym * nc];

   return retval;
}

/*
 * INTEGRAL IMAGE SUBTRACTING THE PLANE: AVERAGE*x*y
 *
 * the vector u[] is stored as RRRR.. GGGGG.. BBBB..
 **/

// This function verifies if the range of the current data can be
// reppresented with an integral image of the precision of iifloat_t.
int check_minmaxOK(iifloat_t * u, int N)
{
   int floatBITS;
   switch (sizeof(iifloat_t)) {
   case 4:
      floatBITS = 24;
      break;			// float
   case 8:
      floatBITS = 53;
      break;			// double
   case 16:
      floatBITS = 112;
      break;			// long double
   default:
      floatBITS = 53;		// default:double
   }

   // TODO: Attention, absmin should be the minimum distance betwee
   // two consecutive values in the sorted data vector. Here we keep the
   // minimum because it is cheap to compute along the maximum.
   double mmax = -INFINITY, mmin = INFINITY;
   double absmmin = INFINITY, absmmax = 0, bits;
   for (int x = 0; x < N; x++) {
      mmin = fmin(u[x], mmin);
      mmax = fmax(u[x], mmax);
      if (u[x] != 0)
	 absmmin = fmin(fabsl(u[x]), absmmin);
      absmmax = fmax(fabsl(u[x]), absmmax);
   }

   // range + #pixels
   bits = log2(absmmax) - log2(absmmin) + log2(N);
   // warn if the precision is not sufficient
   if (bits > floatBITS)
      fprintf(stderr,
	      "ATTENTION: bits needed for the integral image: %lg "
	      "bits available:%d \n|min|:%lg |max|:%lg numpix=%d\n",
	      bits, floatBITS, absmmin, absmmax, N);
   // always return without error
   return 1;
}


struct iimage_t *integralImage(iifloat_t * u, int nc, int nr, int nch)
{
   /*Allocate integral image structure and data as sequential memory
    * containing: nc nr nch AVERAGE[t] ii 
    * The data and the structure can be freed with a single free of the
    * retourned pointer
    * */
   struct iimage_t *integralImage = xmalloc(sizeof(struct iimage_t) +
					    (nc * nr * nch +
					     nch) * sizeof(iifloat_t));
   integralImage->sz[0] = nc;
   integralImage->sz[1] = nr;
   integralImage->sz[2] = nch;
   integralImage->AVERAGE = (void *) (integralImage + 1);
   integralImage->data = integralImage->AVERAGE + nch;
   iifloat_t *AVERAGE = integralImage->AVERAGE;
   iifloat_t *ii = integralImage->data;

   // for each channel
   for (int t = 0; t < nch; t++) {
      int offset = nr * nc * t;

      // check that the image can be represented with the current precision
      assert(check_minmaxOK(u + offset, nc * nr));

#ifdef _USEAVERAGE
      /* extract some statistics of the image */
      iifloat_t AVR = 0;
      for (int x = 0; x < nc * nr; x++)
	 AVR += (iifloat_t) u[x + offset];
      AVERAGE[t] = round(AVR / (nc * nr));

      for (int x = 0; x < nc * nr; x++)
	 u[x + offset] -= AVERAGE[t];
#endif

      // compute the integral image for the current channel
      computeIntegralImage(u + offset, nc, nr, ii + offset);

#ifdef _USEAVERAGE
      for (int x = 0; x < nc * nr; x++)
	 u[x + offset] += AVERAGE[t];
#endif
   }

   return integralImage;
}


iifloat_t evaluateIntegralImage(struct iimage_t * integralImage, int ch,
				int x0, int y0, int w, int h)
{
   int nc = integralImage->sz[0];
   int nr = integralImage->sz[1];
   int nch = integralImage->sz[2];
   iifloat_t *AVERAGE = integralImage->AVERAGE;
   iifloat_t *ii = integralImage->data;
   UNUSED(nch);

   int offset = nr * nc * ch;

#ifndef _USEAVERAGE
   return evaluateIntegralImageBlock(ii + offset, nc, nr, x0, y0, w, h);
#else
   //  If AVERAGE is nonzero it is used to adjust the summed value.
   return evaluateIntegralImageBlock(ii + offset, nc, nr, x0, y0, w, h) +
       AVERAGE[ch] * w * h;
#endif
}
